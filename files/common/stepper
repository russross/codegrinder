#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Audits a student's command against a pre-generated transcript, ensuring
that stdin, stdout, and stderr match the expected behavior precisely.

In grade mode, it runs all tests, continues on error, and produces an
XML report.
"""

import os
import selectors
import subprocess
import sys
import time
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, IO, Tuple, cast, Optional, Deque, Dict, Any
from collections import deque

# ANSI color codes for console output
class Colors:
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'

# Width for aligning prefixes in error reports for readability
ERROR_PREFIX_WIDTH = 20

def print_color(text: str, color: str, bold: bool = False) -> None:
    """Prints text to the console with specified ANSI color."""
    bold_code = Colors.BOLD if bold else ""
    print(f"{bold_code}{color}{text}{Colors.ENDC}", flush=True)

def generate_xml_report(results: List[Dict[str, Any]], tests: int, failures: int, total_time: float) -> None:
    """
    Generates a JUnix-style XML report from the test results.
    """
    outname = 'test_detail.xml'
    testsuites = ET.Element('testsuites')
    suite = ET.SubElement(testsuites, 'testsuite')

    for result in results:
        case = ET.SubElement(suite, 'testcase')
        case.set('name', result['name'])
        case.set('time', f"{result['time']:.4f}")

        if not result['passed']:
            case.set('status', 'failed')
            failure = ET.SubElement(case, 'failure')
            failure.set('type', 'failure')
            # The log contains the full context of the command and error.
            failure.text = result['log']

    suite.set('tests', str(tests))
    suite.set('failures', str(failures))
    suite.set('disabled', '0')
    suite.set('skipped', '0')
    suite.set('errors', '0')
    suite.set('time', f"{total_time:.4f}")

    # Set top-level attributes as well
    testsuites.set('tests', str(tests))
    testsuites.set('failures', str(failures))
    testsuites.set('disabled', '0')
    testsuites.set('skipped', '0')
    testsuites.set('errors', '0')
    testsuites.set('time', f"{total_time:.4f}")

    try:
        if os.path.exists(outname):
            os.remove(outname)
        tree = ET.ElementTree(element=testsuites)
        tree.write(outname, encoding='utf-8', xml_declaration=True)
    except IOError as e:
        print_color(f"FATAL: Could not write XML report to '{outname}': {e}", Colors.RED, bold=True)


def main() -> None:
    """
    Main entry point. Reads environment variables, finds transcript files,
    and orchestrates the test runs.
    """
    # --- 1. Read and Validate Environment Variables ---
    try:
        cmd_str = os.environ['STEPPER_CMD']
        cmd = cmd_str.split()
        stepper_dir = Path(os.environ['STEPPER_DIR'])
        post_error_lines = int(os.environ['STEPPER_POSTERRORLINES'])
        timeout = float(os.environ['STEPPER_TIMEOUT'])
        # Check for STEPPER_GRADE to enable grade mode
        grade_mode = os.environ.get('STEPPER_GRADE', 'false').lower() == 'true'
    except (KeyError, ValueError) as e:
        print_color(f"FATAL: Invalid or missing environment variable: {e}", Colors.RED, bold=True)
        sys.exit(1)

    if not stepper_dir.is_dir():
        print_color(f"FATAL: STEPPER_DIR '{stepper_dir}' is not a valid directory.", Colors.RED, bold=True)
        sys.exit(1)

    # --- 2. Find and Run Test Cases ---
    transcript_files = sorted(list(stepper_dir.glob('*.transcript')))
    if not transcript_files:
        print_color(f"WARNING: No *.transcript files found in '{stepper_dir}'.", Colors.YELLOW)
        sys.exit(0)

    failed_tests = 0
    test_results: List[Dict[str, Any]] = []
    total_start_time = time.monotonic()

    for transcript_path in transcript_files:
        print("-" * 80)
        input_path = transcript_path.with_suffix('.input')
        run_command = f"$ {' '.join(cmd)} < {input_path}"
        print_color(run_command, Colors.YELLOW)
        print() # Add a newline for spacing

        test_start_time = time.monotonic()
        success, error_log = run_test_case(cmd, transcript_path, timeout, post_error_lines)
        duration = time.monotonic() - test_start_time

        if grade_mode:
            # In grade mode, always collect results for the XML report.
            # The error log includes the command that was run for context.
            full_log = f"{run_command}\n\n{error_log}"
            test_results.append({
                "name": transcript_path.name,
                "time": duration,
                "passed": success,
                "log": full_log if not success else ""
            })

        if success:
            print_color("\n✔ Test Passed", Colors.GREEN, bold=True)
        else:
            failed_tests += 1
            if not grade_mode:
                print_color("\nExiting due to test failure.", Colors.RED, bold=True)
                break
    
    print("-" * 80)
    summary_color = Colors.GREEN if failed_tests == 0 else Colors.RED
    total_tests = len(transcript_files)
    passed_tests = total_tests - failed_tests
    total_duration = time.monotonic() - total_start_time
    print_color(f"Passed {passed_tests}/{total_tests} tests in {total_duration:.2f} seconds", summary_color, bold=True)
    if grade_mode:
        # In grade mode, generate the XML report
        generate_xml_report(test_results, total_tests, failed_tests, total_duration)

    sys.exit(failed_tests)

def parse_transcript(path: Path) -> Deque[Tuple[str, str]]:
    """Reads a transcript file and parses it into a deque of (action, content) tuples."""
    actions: Deque[Tuple[str, str]] = deque()
    with open(path, 'r', encoding='utf-8') as f:
        for line in f:
            action = line[0]
            content = line[2:]
            if action not in ('<', '>', '!'):
                raise ValueError(f"Invalid action character '{action}' in transcript '{path}'")
            actions.append((action, content))
    return actions

def run_test_case(cmd: List[str], transcript_path: Path, timeout: float, post_error_lines: int) -> Tuple[bool, str]:
    """
    Runs and audits a single test case against its transcript.
    Returns (True, "") on success, or (False, error_log) on failure.
    """
    try:
        expected_actions = parse_transcript(transcript_path)
    except (IOError, ValueError) as e:
        message = f"FATAL: Could not read or parse transcript '{transcript_path}': {e}"
        print_color(message, Colors.RED, bold=True)
        return False, message

    proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize=0)
    
    # Assertions to satisfy type checker
    assert proc.stdin is not None
    assert proc.stdout is not None
    assert proc.stderr is not None

    os.set_blocking(proc.stdout.fileno(), False)
    os.set_blocking(proc.stderr.fileno(), False)

    sel = selectors.DefaultSelector()
    sel.register(proc.stdout, selectors.EVENT_READ, data='stdout')
    sel.register(proc.stderr, selectors.EVENT_READ, data='stderr')

    partial_stdout = ""
    partial_stderr = ""
    
    try:
        while expected_actions:
            expected_action, expected_content = expected_actions[0]

            if expected_action == '<':
                # --- Handle Expected Input ---
                print_color(expected_content.rstrip('\n') + '⏎', Colors.BLUE)
                try:
                    proc.stdin.write(expected_content.encode('utf-8'))
                    proc.stdin.flush()
                except (IOError, BrokenPipeError):
                    error_log = handle_error("Program closed its input stream prematurely.", proc, sel, expected_actions, post_error_lines, timeout, "", "")
                    return False, error_log
                
                expected_actions.popleft()
                
                # Close stdin once all input has been sent
                if not any(a[0] == '<' for a in expected_actions):
                    proc.stdin.close()

            elif expected_action in ('>', '!'):
                # --- Handle Expected Output ---
                is_stdout = expected_action == '>'
                stream_name = "stdout" if is_stdout else "stderr"
                partial_buffer = partial_stdout if is_stdout else partial_stderr
                
                actual_line: str
                new_buffer: str
                if '\n' in partial_buffer:
                    line, new_buffer = partial_buffer.split('\n', 1)
                    actual_line = line + '\n'
                else:
                    line_from_proc, new_buffer = read_line_from_process(proc, sel, is_stdout, partial_buffer, timeout)
                    if line_from_proc is None:
                        reason = f"Timeout or EOF waiting for output on {stream_name}."
                        if proc.poll() is not None:
                            reason = f"Program exited before producing expected output on {stream_name}."
                        updated_stdout = new_buffer if is_stdout else partial_stdout
                        updated_stderr = new_buffer if not is_stdout else partial_stderr
                        error_log = handle_error(reason, proc, sel, expected_actions, post_error_lines, timeout, updated_stdout, updated_stderr)
                        return False, error_log
                    actual_line = line_from_proc

                if is_stdout:
                    partial_stdout = new_buffer
                else:
                    partial_stderr = new_buffer
                
                if actual_line != expected_content:
                    error_log = handle_error(f"Output mismatch on {stream_name}.", proc, sel, expected_actions, post_error_lines, timeout, partial_stdout, partial_stderr, actual_line)
                    return False, error_log

                # Success, print and continue
                color = "" if is_stdout else Colors.YELLOW
                no_newline = actual_line.rstrip('\n')
                print(f"{color}{no_newline}{Colors.ENDC}")
                expected_actions.popleft()

        # --- Post-Loop Checks ---
        extra_out = partial_stdout
        extra_err = partial_stderr
        
        # Drain any remaining output from the process
        while proc.poll() is None or sel.get_map():
            events = sel.select(0.1) 
            if not events and proc.poll() is not None:
                break

            for key, _ in events:
                fileobj = cast(IO[bytes], key.fileobj)
                try:
                    data = fileobj.read()
                    if not data:
                        sel.unregister(fileobj)
                        continue
                    
                    decoded_data = data.decode('utf-8')
                    if key.data == 'stdout': extra_out += decoded_data
                    else: extra_err += decoded_data
                except (BlockingIOError, UnicodeDecodeError):
                    continue
        
        exit_code = proc.returncode if proc.returncode is not None else proc.wait()

        if extra_out or extra_err:
            error_log = handle_error("Program produced unexpected extra output after completion.", proc, sel, deque(), post_error_lines, timeout, extra_out, extra_err)
            return False, error_log

        if exit_code != 0:
            error_log = handle_error(f"Program exited with non-zero status code: {exit_code}", proc, sel, deque(), post_error_lines, timeout, "", "")
            return False, error_log

    except (IOError, ValueError) as e:
        message = f"Stepper internal error: {e}"
        print_color(message, Colors.RED, bold=True)
        return False, message
    finally:
        # Ensure process and its resources are cleaned up
        if proc.poll() is None:
            proc.terminate()
            proc.wait()
        sel.close()
        for p in [proc.stdin, proc.stdout, proc.stderr]:
            if p and not p.closed:
                p.close()

    return True, ""

def read_line_from_process(proc: subprocess.Popen[bytes], sel: selectors.DefaultSelector, from_stdout: bool, buffer: str, timeout: float) -> Tuple[Optional[str], str]:
    """Reads from process until a full line is available or timeout occurs."""
    start_time = time.monotonic()
    stream_name = 'stdout' if from_stdout else 'stderr'
    
    while time.monotonic() - start_time < timeout:
        remaining_time = timeout - (time.monotonic() - start_time)
        if remaining_time <= 0: break
        
        events = sel.select(remaining_time)
        if not events:
            return None, buffer # Timeout

        for key, _ in events:
            if key.data != stream_name:
                continue
            
            fileobj = cast(IO[bytes], key.fileobj)
            try:
                data = fileobj.read()
                if not data: # EOF
                    return None, buffer
                buffer += data.decode('utf-8')
            except (BlockingIOError, UnicodeDecodeError):
                continue
            
            if '\n' in buffer:
                line, new_buffer = buffer.split('\n', 1)
                return line + '\n', new_buffer
    
    return None, buffer # Timeout

def handle_error(reason: str, proc: subprocess.Popen[bytes], sel: selectors.DefaultSelector, expected_actions: Deque[Tuple[str, str]], post_error_lines: int, timeout: float, partial_stdout: str, partial_stderr: str, mismatched_line: Optional[str] = None) -> str:
    """
    Prints a centralized error report to the console and returns the
    uncolored report as a string for logging.
    """
    log_lines: List[str] = []

    def log_and_print(text: str, color: str = "", bold: bool = False, plain_text: Optional[str] = None) -> None:
        """Helper to print to console and append to log simultaneously."""
        log_lines.append(plain_text if plain_text is not None else text)
        if color:
            print_color(text, color, bold)
        else:
            print(text)

    log_and_print("\n" + "=" * 80, Colors.RED, bold=True)
    log_and_print("TEST FAILED".center(80), Colors.RED, bold=True)
    log_and_print("=" * 80, Colors.RED, bold=True)
    
    log_and_print("\n--- Expected Next Steps ---", Colors.BLUE, bold=True)
    if not expected_actions:
        log_and_print("(No more actions were expected from the transcript)")
    for i, (action, content) in enumerate(expected_actions):
        if i >= post_error_lines: break
        prefix_str = "EXPECTED STDOUT:" if action == '>' else "EXPECTED STDERR:" if action == '!' else "EXPECTED STDIN:"
        prefix = f"{prefix_str:<{ERROR_PREFIX_WIDTH}}"
        color = Colors.YELLOW if action == '!' else Colors.BLUE
        log_and_print(f"{prefix}{repr(content)}", color, plain_text=f"{prefix}{repr(content)}")

    log_and_print("\n--- Actual Program Output (Context) ---", Colors.YELLOW, bold=True)
    lines_shown = 0
    if mismatched_line:
        prefix = f"{'MISMATCHED LINE:':<{ERROR_PREFIX_WIDTH}}"
        log_and_print(f"{prefix}{repr(mismatched_line)}", Colors.YELLOW)
        lines_shown += 1
    
    # Drain any lines already in the partial buffers
    while '\n' in partial_stdout and lines_shown < post_error_lines:
        line, partial_stdout = partial_stdout.split('\n', 1)
        prefix = f"{'SUBSEQUENT STDOUT:':<{ERROR_PREFIX_WIDTH}}"
        newline = '\n'
        log_and_print(f"{prefix}{repr(line + newline)}", Colors.YELLOW)
        lines_shown += 1
    
    while '\n' in partial_stderr and lines_shown < post_error_lines:
        line, partial_stderr = partial_stderr.split('\n', 1)
        prefix = f"{'SUBSEQUENT STDERR:':<{ERROR_PREFIX_WIDTH}}"
        log_and_print(f"{prefix}{repr(line + newline)}", Colors.YELLOW)
        lines_shown += 1

    # Drain subsequent output from the process itself
    start_time = time.monotonic()
    while lines_shown < post_error_lines and time.monotonic() - start_time < timeout and proc.poll() is None:
        if expected_actions and expected_actions[0][0] == '<':
            log_and_print("(Stopping output display as program is expected to wait for input next)", Colors.BLUE)
            break

        line_out, partial_stdout = read_line_from_process(proc, sel, True, partial_stdout, 0.1)
        if line_out is not None:
            prefix = f"{'SUBSEQUENT STDOUT:':<{ERROR_PREFIX_WIDTH}}"
            log_and_print(f"{prefix}{repr(line_out)}", Colors.YELLOW)
            lines_shown += 1
            if lines_shown >= post_error_lines: break
        
        if lines_shown >= post_error_lines: break

        line_err, partial_stderr = read_line_from_process(proc, sel, False, partial_stderr, 0.1)
        if line_err is not None:
            prefix = f"{'SUBSEQUENT STDERR:':<{ERROR_PREFIX_WIDTH}}"
            log_and_print(f"{prefix}{repr(line_err)}", Colors.YELLOW)
            lines_shown += 1

    # Handle the "extra output" case cleanly
    if reason == "Program produced unexpected extra output after completion.":
        if partial_stdout:
            log_and_print("\n--- EXTRA STDOUT ---", Colors.YELLOW)
            log_and_print(repr(partial_stdout), Colors.YELLOW)
        if partial_stderr:
            log_and_print("\n--- EXTRA STDERR ---", Colors.YELLOW)
            log_and_print(repr(partial_stderr), Colors.YELLOW)
    elif lines_shown == 0:
        log_and_print("(No further output from program before timeout or exit)")
        
    log_and_print("\n--- Failure Summary ---", Colors.RED, bold=True)
    log_and_print(f"Reason: {reason}", Colors.RED)
    log_and_print("=" * 80, Colors.RED, bold=True)
    
    return "\n".join(log_lines)

if __name__ == "__main__":
    main()
